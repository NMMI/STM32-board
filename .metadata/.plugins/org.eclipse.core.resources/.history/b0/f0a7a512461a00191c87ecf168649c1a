// ----------------------------------------------------------------------------
// BSD 3-Clause License

// Copyright (c) 2016, qbrobotics
// Copyright (c) 2017-2018, Centro "E.Piaggio"
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.

// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.

// * Neither the name of the copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// POSSIBILITY OF SUCH DAMAGE.
// ----------------------------------------------------------------------------

/**
* \file         command_processing.c
*

* \brief        Command processing functions.
* \date         February 01, 2018
* \author       _Centro "E.Piaggio"_
* \copyright    (C) 2012-2016 qbrobotics. All rights reserved.
* \copyright    (C) 2017-2018 Centro "E.Piaggio". All rights reserved.
*/

//=================================================================     includes
#include "command_processing.h"
#include "interruptions.h"
#include "utils.h"
#include "globals.h"
#include "commands.h"
#include "IMU_functions.h"
#include <STDIO.H>

//================================================================     variables
// [GS] QUESTA LA METTO DOPO
//reg8 * EEPROM_ADDR = (reg8 *) CYDEV_EE_BASE;

//==============================================================================
//                                                            RX DATA PROCESSING
//==============================================================================
//  This function checks for the availability of a data packet and process it:
//      - Verify checksum;
//      - Process commands;
//==============================================================================
void commProcess(){

    uint8_t rx_cmd;
    rx_cmd = g_rx.buffer[0];
	
//==========================================================     verify checksum

    if (!(LCRChecksum(g_rx.buffer, g_rx.length - 1) == g_rx.buffer[g_rx.length - 1])){
        // Wrong checksum
        g_rx.ready = 0;
        return;
    }


    switch(rx_cmd) {
       
//=========================================================     CMD_SET_BAUDRATE
            
//        case CMD_SET_BAUDRATE:
//            cmd_set_baudrate();
//            break;  
            
//=============================================================     CMD_GET_INFO

        case CMD_GET_INFO:
            infoGet( *((uint16_t *) &g_rx.buffer[1]));
            break;

//============================================================     CMD_GET_PARAM
            
        case CMD_GET_PARAM_LIST:
						get_param_list(g_rx.buffer[1] << 8 | g_rx.buffer[2]); 
				break;

//=================================================================     CMD_PING
            
        case CMD_PING:
            cmd_ping();
            break;

//=========================================================     CMD_STORE_PARAMS
            
        case CMD_STORE_PARAMS:
            cmd_store_params();
            break;

//=================================================     CMD_STORE_DEFAULT_PARAMS

        case CMD_STORE_DEFAULT_PARAMS:
            if(memStore(DEFAULT_EEPROM_DISPLACEMENT))
                sendAcknowledgment(ACK_OK);
            else
                sendAcknowledgment(ACK_ERROR);
            break;

//=======================================================     CMD_RESTORE_PARAMS

        //case CMD_RESTORE_PARAMS:
        //    if(memRestore())
        //        sendAcknowledgment(ACK_OK);
        //    else
        //        sendAcknowledgment(ACK_ERROR);
        //    break;

//=============================================================     CMD_INIT_MEM

        case CMD_INIT_MEM:
            if(memInit())
                sendAcknowledgment(ACK_OK);
            else
                sendAcknowledgment(ACK_ERROR);
            break;

//===========================================================     CMD_BOOTLOADER

//        case CMD_BOOTLOADER:
            //Not sure if ACK_OK is correct, should check
//            sendAcknowledgment(ACK_OK);
//            CyDelay(1000);
//            FTDI_ENABLE_REG_Write(0x00);
//            CyDelay(1000);
//            Bootloadable_Load();
//            break;

//=====================================================     CMD_GET_IMU_READINGS

        case CMD_GET_IMU_READINGS:
            cmd_get_imu_readings();
            break;                
            
//=========================================================== ALL OTHER COMMANDS
        default:
            break;
            
    }
}


//==============================================================================
//                                                                     INFO SEND
//==============================================================================
void infoSend(){
    unsigned char packet_string[1500];
    infoPrepare(packet_string);
    HAL_GPIO_WritePin(RS485_EN_GPIO_Port, RS485_EN_Pin, 1);
	HAL_UART_Transmit(&huart1, (uint8_t*)packet_string, strlen(packet_string), 40);
	HAL_GPIO_WritePin(RS485_EN_GPIO_Port, RS485_EN_Pin, 0);
}


//==============================================================================
//                                                              COMMAND GET INFO
//==============================================================================
void infoGet(uint16_t info_type) {
    static unsigned char packet_string[1100] = " ";

    //==================================     choose info type and prepare string
    // [info_reading] 
    switch (info_type) {
        case INFO_ALL:
            infoPrepare(packet_string);
            HAL_GPIO_WritePin(RS485_EN_GPIO_Port, RS485_EN_Pin, 1);
		    HAL_UART_Transmit(&huart1, (uint8_t*)packet_string, strlen(packet_string), 5);
            HAL_GPIO_WritePin(RS485_EN_GPIO_Port, RS485_EN_Pin, 0);
            break;
        case INFO_READING:
        	infoReading(packet_string);
            HAL_GPIO_WritePin(RS485_EN_GPIO_Port, RS485_EN_Pin, 1);
			HAL_UART_Transmit(&huart1, (uint8_t*)packet_string, strlen(packet_string), 5);
            HAL_GPIO_WritePin(RS485_EN_GPIO_Port, RS485_EN_Pin, 0);
            break;
        default:
            break;
    }
}

//==============================================================================
//                                                           PREPARE DEVICE INFO
//==============================================================================

void infoPrepare(unsigned char *info_string)
{
    int i,j;
    unsigned char str[500]= "";
    if(c_mem.id != 250){                //To avoid dummy board ping
        strcpy(info_string, "");
        strcat(info_string, "\r\n");
        strcat(info_string, "Firmware version: ");
        strcat(info_string, VERSION);
        strcat(info_string, "\r\n\r\n");

        strcat(info_string, "DEVICE INFO\r\n");
        sprintf(str, "ID: %d\r\n", (uint16_t)(c_mem.id));
        strcat(info_string, str);
        
        if (g_mem.read_imu) {

        	sprintf(str, "IMU Connected: %d\r\n", (uint16_t) N_IMU_Connected);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");
        
        	strcat(info_string, "IMUs CONFIGURATION\r\n");
        	for (i=0; i<N_IMU_Connected; i++){
        		sprintf(str, "Imu %d \r\n\tID: %d\r\n", i, (uint16_t) IMU_connected[i]);
        		strcat(info_string, str);
            
        		sprintf(str, "\tAccelerometers: ");
        		if ((c_mem.IMU_conf[IMU_connected[i]][0]))
        			strcat(str, "YES\r\n");
        		else
        			strcat(str, "NO\r\n");
        		strcat(str, "\tGyroscopes: ");
        		if ((c_mem.IMU_conf[IMU_connected[i]][1]))
        			strcat(str, "YES\r\n");
        		else
        			strcat(str, "NO\r\n");
        		strcat(str, "\tMagnetometers: ");
        		if ((c_mem.IMU_conf[IMU_connected[i]][2]))
                strcat(str, "YES\r\n");
        		else
        			strcat(str, "NO\r\n");
        		strcat(str, "\tQuaternion: ");
        		if ((c_mem.IMU_conf[IMU_connected[i]][3]))
        			strcat(str, "YES\r\n");
        		else
        			strcat(str, "NO\r\n");
        		strcat(str, "\tTemperature: ");
        		if ((c_mem.IMU_conf[IMU_connected[i]][4]))
        			strcat(str, "YES\r\n");
        		else
        			strcat(str, "NO\r\n");
                 
        		strcat(info_string, str);
        	}

        	strcat(info_string, "\r\n");
        }
        
        if (g_mem.read_encoders) { // [GS] 2019/01/16 va riscritta in modo da stampare a video tutte le misure di tutti gli encoder connessi

        	sprintf(str, "Number of Connected Encoder: %d", N_Encoder_Connected);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");

        	sprintf(str, "Encoder Map: [");
        	strcat(info_string, str);
        	for (i=0; i<N_ENCODER_MAX-1; i++) {
        		sprintf(str, "%d, ", Encoder_Map[i]);
        		strcat(info_string, str);
        	}
        	sprintf(str, "%d", Encoder_Map[N_ENCODER_MAX-1]);
        	strcat(info_string, str);
    		sprintf(str, "]");
    		strcat(info_string, str);
        	strcat(info_string, "\r\n");

        	for (i=0; i<N_ENCODER_MAX; i++) {
        		if (Encoder_Map[i] != 0) {
                	sprintf(str, "ENCODERS LINE %d: ",i);
                	strcat(info_string, str);
                	strcat(info_string, "\r\n");
                	for (j=0; j<Encoder_Map[i]+1; j++){
                    	sprintf(str, "Encoder %d Measurement: %u", j+1, Encoder_Value[i][j]);
                    	strcat(info_string, str);
                    	sprintf(str, ", Check Value Encoder %d: %u", j+1, Encoder_Check[i][j]);
                    	strcat(info_string, str);
                    	strcat(info_string, "\r\n");
                	}
        		}
        	}

/*
        	sprintf(str, "Meas. Encoder 2: %u", encoder_aux_2);
        	strcat(info_string, str);
        	sprintf(str, ", Check Encoder 2: %u", check_aux_2);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");
        	sprintf(str, "Meas. Encoder 3: %u", encoder_aux_3);
        	strcat(info_string, str);
        	sprintf(str, ", Check Encoder 3: %u", check_aux_3);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");
        	sprintf(str, "Meas. Encoder 4: %u", encoder_aux_4);
        	strcat(info_string, str);
        	sprintf(str, ", Check Encoder 4: %u", check_aux_4);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");
        	sprintf(str, "Meas. Encoder 5: %u", encoder_aux_5);
        	strcat(info_string, str);
        	sprintf(str, ", Check Encoder 5: %u", check_aux_5);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");
        	sprintf(str, "Meas. Encoder 6: %u", encoder_aux_6);
        	strcat(info_string, str);
        	sprintf(str, ", Check Encoder 6: %u", check_aux_6);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");
        	sprintf(str, "Meas. Encoder 7: %u", encoder_aux_7);
        	strcat(info_string, str);
        	sprintf(str, ", Check Encoder 7: %u", check_aux_7);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");
        	sprintf(str, "Meas. Encoder 8: %u", encoder_aux_8);
        	strcat(info_string, str);
        	sprintf(str, ", Check Encoder 8: %u", check_aux_8);
        	strcat(info_string, str);
        	strcat(info_string, "\r\n");
*/

        }
        
        sprintf(str, "Time between two reading cycles: %.3f ms", execution_time_ms);
        strcat(info_string, str);
        strcat(info_string, "\r\n");
        
		sprintf(str, "Time between two reading cycles: %ld us", (uint32_t)(execution_time_us));
        strcat(info_string, str);
        strcat(info_string, "\r\n");
				
    }
}

void infoReading(unsigned char* info_string)
{
    int i;
    unsigned char str[100];
    
    strcpy(info_string, "");
    strcat(info_string, "\r\n");           
    strcat(info_string, "SENSORS INFO\r\n");
    for (i=0; i<N_IMU_Connected; i++){
        sprintf(str, "Imu %d \r\n\tID: %d\r\n", i, (int) IMU_connected[i]);
        strcat(info_string, str);
        
			sprintf(str, "\tMagCal Parameters %d\t%d\t%d\r\n", (uint8_t) MagCal[IMU_connected[i]][0], (uint8_t) MagCal[IMU_connected[i]][1], (uint8_t) MagCal[IMU_connected[i]][2]);
        strcat(info_string, str);
			
        if ((c_mem.IMU_conf[IMU_connected[i]][0])){
            sprintf(str, "\tAcc (Norm on last column): %d\t%d\t%d\t%d\r\n", (int16_t) g_imu[i].accel_value[0], (int16_t) g_imu[i].accel_value[1],(int16_t) g_imu[i].accel_value[2], (int16_t) sqrt(g_imu[i].accel_value[0]*g_imu[i].accel_value[0] + g_imu[i].accel_value[1]*g_imu[i].accel_value[1] + g_imu[i].accel_value[2]*g_imu[i].accel_value[2]));
            strcat(info_string, str);
        }

        if ((c_mem.IMU_conf[IMU_connected[i]][1])){
            sprintf(str, "\tGyro: %d\t%d\t%d\r\n", (int16_t) g_imu[i].gyro_value[0], (int16_t) g_imu[i].gyro_value[1],(int16_t) g_imu[i].gyro_value[2]);
            strcat(info_string, str);
        }

        if ((c_mem.IMU_conf[IMU_connected[i]][2])){
            sprintf(str, "\tMag: %d\t%d\t%d\r\n", (int16_t) g_imu[i].mag_value[0], (int16_t) g_imu[i].mag_value[1],(int16_t) g_imu[i].mag_value[2]);
            strcat(info_string, str);
        }
        
        if ((c_mem.IMU_conf[IMU_connected[i]][3])){
            sprintf(str, "\tQuat (Norm on last column): %.3f\t%.3f\t%.3f\t%.3f\t%.3f\r\n", (float) g_imu[i].quat_value[0], (float) g_imu[i].quat_value[1],(float) g_imu[i].quat_value[2], (float) g_imu[i].quat_value[3] , (float)sqrt(g_imu[i].quat_value[0]*g_imu[i].quat_value[0]+g_imu[i].quat_value[1]*g_imu[i].quat_value[1]+g_imu[i].quat_value[2]*g_imu[i].quat_value[2]+g_imu[i].quat_value[3]*g_imu[i].quat_value[3]));
            strcat(info_string, str);
        }
        
        if ((c_mem.IMU_conf[IMU_connected[i]][4])){
            sprintf(str, "\tTemperature: %d\r\n", (int16_t) g_imu[i].temp_value);
            strcat(info_string, str);
        }
    }
		
	strcat(info_string, "\r\n");
        
    sprintf(str, "Time between two reading cycles: %.3f ms", execution_time_ms);
    strcat(info_string, str);
    strcat(info_string, "\r\n");
        
	sprintf(str, "Time between two reading cycles: %ld us", (uint32_t)(execution_time_us));
    strcat(info_string, str);
    strcat(info_string, "\r\n");
    strcat(info_string, "\r\n");

}

//==============================================================================
//                                                      WRITE FUNCTION FOR RS485
//==============================================================================

void commWrite(uint8_t *packet_data, const uint16_t packet_lenght)
{
	
		uint16_t aux_var = packet_lenght; 
		uint8_t packet_lenght_high = aux_var >> 8;
		aux_var = aux_var << 8;
		uint8_t packet_lenght_low = aux_var >> 8;		
		// frame - start
		HAL_GPIO_WritePin(RS485_EN_GPIO_Port, RS485_EN_Pin, 1);
		HAL_UART_Transmit(&huart1, (uint8_t*)":", 1, HAL_MAX_DELAY);
		HAL_UART_Transmit(&huart1, (uint8_t*)":", 1, HAL_MAX_DELAY);
    
		// frame - ID
		HAL_UART_Transmit(&huart1, (uint8_t*)&g_mem.id, 1, HAL_MAX_DELAY);
		//HAL_UART_Transmit(&huart1, &packet_lenght_high, 1, 5);
		HAL_UART_Transmit(&huart1, &packet_lenght_low, 1, HAL_MAX_DELAY);			 
		// frame - packet data
		HAL_UART_Transmit(&huart1, packet_data, packet_lenght, HAL_MAX_DELAY);
	
		HAL_GPIO_WritePin(RS485_EN_GPIO_Port, RS485_EN_Pin, 0);
		HAL_GPIO_WritePin(RS485_CTS_GPIO_Port, RS485_CTS_Pin, 1);
		HAL_GPIO_WritePin(RS485_CTS_GPIO_Port, RS485_CTS_Pin, 0);

}

//==============================================================================
//                                                             CHECKSUM FUNCTION
//==============================================================================
// Performs a XOR byte by byte on the entire vector
uint8_t LCRChecksum(uint8_t *data_array, uint8_t data_length) {
    
    uint8_t i;
    uint8_t checksum = 0x00;
    
    for(i = 0; i < data_length; ++i)
       checksum ^= data_array[i];
  
    return checksum;
}

//==============================================================================
//                                                       ACKNOWLEDGMENT FUNCTION
//==============================================================================
void sendAcknowledgment(const uint8_t value) {
    int packet_lenght = 2;
    uint8_t packet_data[2];

    packet_data[0] = value;
    packet_data[1] = value;

    commWrite(packet_data, packet_lenght);
}

//==============================================================================
//                                                                  STORE MEMORY
//==============================================================================

/**
* This function stores current memory settings on the eeprom with the specified
* displacement
**/

uint8_t memStore(int displacement)
{
		// displacement is not used
    int i;  // iterator
    int blocks;
  	int flash_error = 0;
		HAL_StatusTypeDef error;
		uint16_t aux_var[blocks];
		uint32_t Flash_Sector_Error=0;
	
    memcpy( &c_mem, &g_mem, sizeof(g_mem) );
	  // How much blocks are written (each block is composed by 2 byte)
	  // Il sizeof counts byte e.g sizeof(int32) = 4
	  blocks = sizeof(g_mem) / 2 + (sizeof(g_mem) % 2 > 0);
	  HAL_FLASH_Unlock(); // Unlock the flash memory
		HAL_Delay(1);
												
		while (flash_error == 0){
			if (HAL_FLASHEx_Erase(&mem_settings, &Flash_Sector_Error) == HAL_OK) {
				flash_error = 1;
			}	
		} 
		
		HAL_Delay(1);	
		// 1 WORD = 4 byte											 
		for(i=0; i < blocks; i++) {
			  HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, (FLASH_STARTING_ADDRESS + 2*i), *(&g_mem.flag + i));
			  HAL_Delay(1);
		}	
		HAL_Delay(1);
		HAL_FLASH_Lock();
		
    memcpy( &g_mem, &c_mem, sizeof(g_mem) );

	return 0;
}
//==============================================================================
//                                                                 RECALL MEMORY
//==============================================================================

/**
* This function loads user settings from the eeprom.
**/

void memRecall() {
	uint16_t i;
	int blocks;
	uint16_t aux_var[blocks];
	blocks = sizeof(g_mem) / 2 + (sizeof(g_mem) % 2 > 0);
		//g_mem.id = *(uint8_t*)FLASH_STARTING_ADDRESS;
   for (i = 0; i < blocks; i++) {
			*(&g_mem.flag + i)  = *(uint16_t*)(FLASH_STARTING_ADDRESS + 2*i);	 
	 }

    //check for initialization
    if (g_mem.flag == TRUE) {
        memcpy( &c_mem, &g_mem, sizeof(g_mem) );
    }
}

//==============================================================================
//                                                                RESTORE MEMORY
//==============================================================================

/**
* This function loads default settings from the eeprom.
**/
// [GS] TUTTE QUESTE FUNZIONI LE REINSERISCO MAN MANO CHE MI SERVONO

//uint8_t memRestore() {
//    uint16_t i;
//		int blocks;
//  	int flash_error = 0;
//		uint32_t Flash_Sector_Error=0;
//   	blocks = sizeof(g_mem) / 2 + (sizeof(g_mem) % 2 > 0);

//    for (i = 0; i < blocks; i++) {
//			*(&g_mem.flag + i)  = *(uint16_t*)(FLASH_STARTING_ADDRESS + 2*i + DEFAULT_EEPROM_DISPLACEMENT);	 
//	  }	

    //check for initialization
//    if (g_mem.flag == FALSE) {
//        return memInit();
//    } else {
//        return memStore(0);
//    }
//}	

//==============================================================================
//                                                                   MEMORY INIT
//==============================================================================
/**
* This function initialize memory when eeprom is compromised.
**/

uint8_t memInit()
{
    uint8_t i;
    
    //initialize memory settings
    g_mem.id            = 10;

    
    // set the initialized flag to show EEPROM has been populated
    g_mem.flag = TRUE;
    
    // Default value
    for (i = 0; i< N_IMU_MAX; i++){
        g_mem.IMU_conf[i][0] = 1;
        g_mem.IMU_conf[i][1] = 1;
        g_mem.IMU_conf[i][2] = 0;
        g_mem.IMU_conf[i][3] = 0;
        g_mem.IMU_conf[i][4] = 0;
    }
    
		g_mem.SPI_read_delay = 0;
		g_mem.read_imu = 0;
		g_mem.read_encoders = 0;
		g_mem.read_motor = 0;
		g_mem.read_exp_port = 0;
		
    //write that configuration to EEPROM
    return ( memStore(0) );
}

//==============================================================================
//                                                    ROUTINE INTERRUPT FUNCTION
//==============================================================================
/**
* Bunch of functions used on request from UART communication
**/
// [GS] TUTTE QUESTE FUNZIONI LE REINSERISCO MAN MANO CHE MI SERVONO
/*
void cmd_set_baudrate(){
    
    // Set BaudRate
    c_mem.baud_rate = g_rx.buffer[1];
    
    switch(g_rx.buffer[1]){
        case 13:
            CLOCK_UART_SetDividerValue(13);
            break;
        default:
            CLOCK_UART_SetDividerValue(3);
    }
}
*/

void cmd_ping(){

    uint8_t packet_data[2];

    // Header
    packet_data[0] = CMD_PING;
    
    // Load Payload
    packet_data[1] = CMD_PING;

    // Send Package to uart
    commWrite(packet_data, 2);
}

void cmd_store_params(){
   
    if(memStore(0))
        sendAcknowledgment(ACK_OK);
    else
        sendAcknowledgment(ACK_ERROR);
}

void cmd_get_imu_readings(){
    //Retrieve accelerometers, gyroscopes and magnetometers readings
    
    uint8_t k_imu;
    static uint16_t c = 1;
    uint8_t k = 0;
    uint16_t gl_c = 1;
	int16_t q0, q1, q2, q3;
	uint16_t quat_int_scale = 20000;
    
    // Packet: header + imu id(uint8) + imu flags(uint8) + crc  
    uint8_t packet_data[350];
    uint8_t single_packet[32];
    
    //Header package 
    packet_data[0] = CMD_GET_IMU_READINGS;
 					  
    for (k_imu = 0; k_imu < N_IMU_Connected; k_imu++) 
    {	
			
				single_packet[0] = (uint8_t) 0x3A; //':';
        if (c_mem.IMU_conf[IMU_connected[k_imu]][0]){ // Acceleromters 
            *((int8_t *) &single_packet[c+0]) = Accel[IMU_connected[k_imu]][0];
            *((int8_t *) &single_packet[c+1]) = Accel[IMU_connected[k_imu]][1];
            *((int8_t *) &single_packet[c+2]) = Accel[IMU_connected[k_imu]][2];
            *((int8_t *) &single_packet[c+3]) = Accel[IMU_connected[k_imu]][3];
            *((int8_t *) &single_packet[c+4]) = Accel[IMU_connected[k_imu]][4];
			*((int8_t *) &single_packet[c+5]) = Accel[IMU_connected[k_imu]][5];
            c = c + 6;
        }
        if (c_mem.IMU_conf[IMU_connected[k_imu]][1]){ // Gyroscopes
			*((int8_t *) &single_packet[c+0]) = Gyro[IMU_connected[k_imu]][0];
			*((int8_t *) &single_packet[c+1]) = Gyro[IMU_connected[k_imu]][1];
            *((int8_t *) &single_packet[c+2]) = Gyro[IMU_connected[k_imu]][2];
			*((int8_t *) &single_packet[c+3]) = Gyro[IMU_connected[k_imu]][3];
			*((int8_t *) &single_packet[c+4]) = Gyro[IMU_connected[k_imu]][4];
			*((int8_t *) &single_packet[c+5]) = Gyro[IMU_connected[k_imu]][5];
            c = c + 6;
        }
        if (c_mem.IMU_conf[IMU_connected[k_imu]][2]){ // Magnetometers
			*((int8_t *) &single_packet[c+0]) = Mag[IMU_connected[k_imu]][0];
			*((int8_t *) &single_packet[c+1]) = Mag[IMU_connected[k_imu]][1];
            *((int8_t *) &single_packet[c+2]) = Mag[IMU_connected[k_imu]][2];
			*((int8_t *) &single_packet[c+3]) = Mag[IMU_connected[k_imu]][3];
			*((int8_t *) &single_packet[c+4]) = Mag[IMU_connected[k_imu]][4];
			*((int8_t *) &single_packet[c+5]) = Mag[IMU_connected[k_imu]][5];
            c = c + 6;
        }
        if (c_mem.IMU_conf[IMU_connected[k_imu]][3]){ // Quaternions
					  		
		    q0 = (int16_t)((float)(Quat[IMU_connected[k_imu]][0] * quat_int_scale));
			q1 = (int16_t)((float)(Quat[IMU_connected[k_imu]][1] * quat_int_scale));
			q2 = (int16_t)((float)(Quat[IMU_connected[k_imu]][2] * quat_int_scale));
			q3 = (int16_t)((float)(Quat[IMU_connected[k_imu]][3] * quat_int_scale));
					
   			*((int8_t *) &single_packet[c+0]) = (q0 >> 8);
            *((int8_t *) &single_packet[c+1]) = ((q0 << 8) >> 8); 
			*((int8_t *) &single_packet[c+2]) = (q1 >> 8);
            *((int8_t *) &single_packet[c+3]) = ((q1 << 8) >> 8); 
			*((int8_t *) &single_packet[c+4]) = (q2 >> 8);
			*((int8_t *) &single_packet[c+5]) = ((q2 << 8) >> 8);
			*((int8_t *) &single_packet[c+6]) = (q3 >> 8);
            *((int8_t *) &single_packet[c+7]) = ((q3 << 8) >> 8); 
            c = c + 8;
        }
        if (c_mem.IMU_conf[IMU_connected[k_imu]][4]){ // Temperatures
            *((int8_t *) &single_packet[c+0]) = (int8_t) Temp[IMU_connected[k_imu]][0]; 
			*((int8_t *) &single_packet[c+1]) = (int8_t) Temp[IMU_connected[k_imu]][1];
            c = c + 2;
        }
        single_packet[single_imu_size[IMU_connected[k_imu]] - 1] = (uint8_t) 0x3A; //':';
        c = 1;
               
        for(k=0; k < single_imu_size[IMU_connected[k_imu]]; k++) {
            packet_data[gl_c + k] = (uint8_t) single_packet[k]; 
        }
        gl_c = gl_c + single_imu_size[IMU_connected[k_imu]];  
        
        memset(&single_packet, 0, sizeof(single_packet));     
        
    }

    // Calculate Checksum and send message to UART 
    packet_data[imus_data_size-1] = LCRChecksum (packet_data, imus_data_size-1);
    commWrite(packet_data, imus_data_size);
}



uint16_t value_swap(uint16_t input) {

  uint8_t high, low;
	uint16_t aux_var;
	
  high = input >> 8;
	aux_var = (input << 8);
	low = aux_var >> 8;
	return ((low << 8) | high);
	
}

//==============================================================================
//                                                            GET PARAMETER LIST
//==============================================================================

void get_param_list(uint16_t index){

	//Auxiliary variables
    uint16_t i, j, k, h;
    uint16_t start_byte = 0;
	
    //Package to be sent variables
    uint16_t num_imus_id_params = 6;
    uint16_t num_mag_cal_params = 0;
    uint16_t first_imu_parameter = 2;
    uint16_t packet_length = PARAM_BYTE_SLOT + num_imus_id_params*PARAM_BYTE_SLOT + num_mag_cal_params*PARAM_BYTE_SLOT + PARAM_BYTE_SLOT + (uint16_t)(PARAM_BYTE_SLOT*N_IMU_Connected) + 5*PARAM_BYTE_SLOT + 3*PARAM_MENU_SLOT + PARAM_BYTE_SLOT + 1;

    //Parameters menu string definitions
    char n_imu_str[]          = "Number of connected IMUs:";
    char ids_str[11]            = " ";
    char mag_param_str[20]      = "Mag cal parameters:";
    char id_str[16]             = " ";
    char imu_table_str[42]      = " ";
    char spi_read_delay_str[26] = " ";
    char imu_read_str[24]		= " ";
    char encoder_read_str[24]	= " ";
    char motor_read_str[21]		= " ";
    char exp_port_read_str[39]	= " ";
    //Strings lenghts

    uint8_t id_str_len = strlen(id_str);
    uint8_t n_imu_str_len = strlen(n_imu_str);
    uint8_t ids_str_len = strlen(ids_str);
    uint8_t mag_param_str_len = strlen(mag_param_str);
    uint8_t imu_table_str_len = strlen(imu_table_str);
    uint8_t spi_read_delay_str_len = strlen(spi_read_delay_str);
    uint8_t imu_read_str_len = strlen(imu_read_str);
    uint8_t encoder_read_str_len = strlen(encoder_read_str);
    uint8_t motor_read_str_len = strlen(motor_read_str);
    uint8_t exp_port_read_str_len = strlen(exp_port_read_str);
    char spi_delay_menu[118]    = " ";
    uint8_t spi_delay_menu_len;
    
    sprintf(spi_delay_menu, "0 -> None\n1 -> Low (%u us delay for each 8-bit register read)\n2 -> High (%u us delay for each 8-bit register read)\n", (int)SPI_DELAY_LOW, (int)SPI_DELAY_HIGH);
    spi_delay_menu_len = strlen(spi_delay_menu);

    char on_off_menu[51] = "0 -> OFF\n1 -> ON\nYou must restart the board now\n";
    char exp_port_menu[87] = "0 -> None\n1 -> SD/RTC board\n2 -> WiFi board\n3 -> Other\nYou must restart the board now\n";
    uint8_t on_off_menu_len = strlen(on_off_menu);
    uint8_t exp_port_menu_len = strlen(exp_port_menu);


    // Compute number of read parameters depending on N_IMU_Connected and
    // update packet_length
    num_mag_cal_params = (uint16_t)(N_IMU_Connected / 2);
    if ( (N_IMU_Connected - num_mag_cal_params*2) > 0 ) {num_mag_cal_params++;}
    
    packet_length = PARAM_BYTE_SLOT + num_imus_id_params*PARAM_BYTE_SLOT + num_mag_cal_params*PARAM_BYTE_SLOT + PARAM_BYTE_SLOT + (uint16_t)(PARAM_BYTE_SLOT*N_IMU_Connected) + 5*PARAM_BYTE_SLOT + 3*PARAM_MENU_SLOT + PARAM_BYTE_SLOT + 1;
		
    
    first_imu_parameter = 1 + num_imus_id_params + num_mag_cal_params + 2;
    packet_data_param[0] = CMD_GET_PARAM_LIST;
    packet_data_param[1] = 1 + num_imus_id_params + num_mag_cal_params + 1 + (uint8_t)N_IMU_Connected + 5;        // NUM_PARAMS
		
		
    switch(index) {
        case 0:         
			//List of all parameters with relative types
			/*-------------N IMU--------------*/
            start_byte = 0;
            packet_data_param[2] = TYPE_UINT8;
            packet_data_param[3] = 1;
            packet_data_param[4] = (uint8_t)N_IMU_Connected;
            for(i = n_imu_str_len; i != 0; i--)
                {packet_data_param[5 + n_imu_str_len - i] = n_imu_str[n_imu_str_len - i];}	
								
            /*-------------IMUS ID--------------*/
			start_byte = start_byte + PARAM_BYTE_SLOT;
            i = 0;
            for (k = 0; k < num_imus_id_params; k++){
                sprintf(ids_str, "Port %u ID:", k);
                h = 4;
                ids_str_len = strlen(ids_str);
                packet_data_param[2+start_byte + PARAM_BYTE_SLOT*k] = TYPE_UINT8;
                packet_data_param[3+start_byte + PARAM_BYTE_SLOT*k] = 3;
                
                for (j = 3*k; j <= 3*k+2; j++) {  // for each possible imu on port k
                    if (IMU_connected[i] == j) {
                        packet_data_param[h+start_byte + PARAM_BYTE_SLOT*k] = (uint8_t)IMU_connected[i];               
                        i++;
                    } else {
                        packet_data_param[h+start_byte + PARAM_BYTE_SLOT*k] = 255;
                    }
                    h++;
                }

                for(j = ids_str_len; j != 0; j--)
                    packet_data_param[7+start_byte + PARAM_BYTE_SLOT*k + ids_str_len - j] = ids_str[ids_str_len - j];
			}
            
            /*-------------GET MAG PARAM--------------*/
    
			start_byte = start_byte + PARAM_BYTE_SLOT*num_imus_id_params; // num_imus_id_params = 6;
            for (k = 0; k < num_mag_cal_params; k++){ // num_mag_cal_params = 1
                packet_data_param[2+start_byte + PARAM_BYTE_SLOT*k] = TYPE_UINT8;
                packet_data_param[3+start_byte + PARAM_BYTE_SLOT*k] = 3;
                packet_data_param[4+start_byte + PARAM_BYTE_SLOT*k] = (uint8_t) MagCal[IMU_connected[2*k]][0];
                packet_data_param[5+start_byte + PARAM_BYTE_SLOT*k] = (uint8_t) MagCal[IMU_connected[2*k]][1];
                packet_data_param[6+start_byte + PARAM_BYTE_SLOT*k] = (uint8_t) MagCal[IMU_connected[2*k]][2];
                
                // check if there is a second value
                if ( N_IMU_Connected < 2*(k+1) ) {
                    // there is only one value
                    for(j = mag_param_str_len; j != 0; j--)
                        {packet_data_param[7+start_byte + PARAM_BYTE_SLOT*k + mag_param_str_len - j] = mag_param_str[mag_param_str_len - j];}
                } else {
                    // fill the second value
                    packet_data_param[3+start_byte + PARAM_BYTE_SLOT*k] = 6;
                    packet_data_param[7+start_byte + PARAM_BYTE_SLOT*k] = MagCal[IMU_connected[2*k+1]][0];
                    packet_data_param[8+start_byte + PARAM_BYTE_SLOT*k] = MagCal[IMU_connected[2*k+1]][1];
                    packet_data_param[9+start_byte + PARAM_BYTE_SLOT*k] = MagCal[IMU_connected[2*k+1]][2];
                    for(j = mag_param_str_len; j != 0; j--)
                        {packet_data_param[10+start_byte + PARAM_BYTE_SLOT*k + mag_param_str_len - j] = mag_param_str[mag_param_str_len - j];} // [GS] questo passaggio non mi è' ancora chiaro
                }
            }
            
            /*-----------------ID-----------------*/
  			start_byte = start_byte + PARAM_BYTE_SLOT*num_mag_cal_params;
            sprintf(id_str, "%u - Device ID:", first_imu_parameter-1);
            id_str_len = strlen(id_str);
            packet_data_param[2+start_byte] = TYPE_UINT8;
            packet_data_param[3+start_byte] = 1;
            packet_data_param[4+start_byte] = c_mem.id;
            for(i = id_str_len; i != 0; i--)
                {packet_data_param[5+start_byte + id_str_len - i] = id_str[id_str_len - i];}
						
            /*-------------GET IMUS MODE-------------*/
			start_byte = start_byte + PARAM_BYTE_SLOT;
            for (i = 0; i < (uint8_t)N_IMU_Connected; i++){
                sprintf(imu_table_str, "%u - IMU %d configuration:", first_imu_parameter + i, (int) IMU_connected[i]);
                imu_table_str_len = strlen(imu_table_str);
            
                packet_data_param[(uint16_t)(2 + start_byte + PARAM_BYTE_SLOT*i)] = TYPE_UINT8;
                packet_data_param[(uint16_t)(3 + start_byte + PARAM_BYTE_SLOT*i)] = 5;
                
                packet_data_param[(uint16_t)(4 + start_byte + PARAM_BYTE_SLOT*i)] = (uint8_t)(c_mem.IMU_conf[IMU_connected[i]][0]);
                packet_data_param[(uint16_t)(5 + start_byte + PARAM_BYTE_SLOT*i)] = (uint8_t)(c_mem.IMU_conf[IMU_connected[i]][1]);
                packet_data_param[(uint16_t)(6 + start_byte + PARAM_BYTE_SLOT*i)] = (uint8_t)(c_mem.IMU_conf[IMU_connected[i]][2]);
                packet_data_param[(uint16_t)(7 + start_byte + PARAM_BYTE_SLOT*i)] = (uint8_t)(c_mem.IMU_conf[IMU_connected[i]][3]);
                packet_data_param[(uint16_t)(8 + start_byte + PARAM_BYTE_SLOT*i)] = (uint8_t)(c_mem.IMU_conf[IMU_connected[i]][4]);

                for(j = imu_table_str_len; j != 0; j--)
                    {packet_data_param[(uint16_t)(9 + start_byte + PARAM_BYTE_SLOT*i + imu_table_str_len - j)] = imu_table_str[imu_table_str_len - j];}
            }  
		
            /*-----------------SPI DELAY-----------------*/
            
			start_byte = start_byte + (uint16_t)(PARAM_BYTE_SLOT*N_IMU_Connected) ;
            sprintf(spi_read_delay_str, "%u - SPI read delay:", first_imu_parameter+N_IMU_Connected);
            packet_data_param[2+start_byte] = TYPE_FLAG;
            packet_data_param[3+start_byte] = 1;
            packet_data_param[4+start_byte] = c_mem.SPI_read_delay;
            switch(c_mem.SPI_read_delay) {
                case 0: 
                    strcat(spi_read_delay_str, " None"); 
                    spi_read_delay_str_len = 26;
                    break;
                case 1: 
                    strcat(spi_read_delay_str, " Low"); 
                    spi_read_delay_str_len = 25;
                    break;
                case 2: 
                    strcat(spi_read_delay_str, " High");
                    spi_read_delay_str_len = 26;
                    break;
                default:
					strcat(spi_read_delay_str, " Undefined");
                    spi_read_delay_str_len = 32;

                    break;
            }            
            for(i = spi_read_delay_str_len; i != 0; i--)
                {packet_data_param[5+start_byte + spi_read_delay_str_len - i] = spi_read_delay_str[spi_read_delay_str_len - i];}
            //The following byte indicates the number of menus at the end of the packet to send
            packet_data_param[5+start_byte + spi_read_delay_str_len] = 1;

            /*-----------------IMU READ-----------------*/

			start_byte = start_byte + (uint16_t)(PARAM_BYTE_SLOT) ;
            sprintf(imu_read_str, "%u - Read all IMUs:", first_imu_parameter+N_IMU_Connected+1);
            packet_data_param[2+start_byte] = TYPE_FLAG;
            packet_data_param[3+start_byte] = 1;
            packet_data_param[4+start_byte] = c_mem.read_imu;
            switch(c_mem.read_imu) {
                case 0:
                    strcat(imu_read_str, " OFF");
                    imu_read_str_len = 24;
                    break;
                case 1:
                    strcat(imu_read_str, " ON");
                    imu_read_str_len = 23;
                    break;
            }
            for(i = imu_read_str_len; i != 0; i--)
                {packet_data_param[5+start_byte + imu_read_str_len - i] = imu_read_str[imu_read_str_len - i];}
            //The following byte indicates the number of menus at the end of the packet to send
            packet_data_param[5+start_byte + imu_read_str_len] = 2;

            /*-----------------ENCODER READ-----------------*/

			start_byte = start_byte + (uint16_t)(PARAM_BYTE_SLOT) ;
            sprintf(encoder_read_str, "%u - Read Encoders:", first_imu_parameter+N_IMU_Connected+2);
            packet_data_param[2+start_byte] = TYPE_FLAG;
            packet_data_param[3+start_byte] = 1;
            packet_data_param[4+start_byte] = c_mem.read_encoders;
            switch(c_mem.read_encoders) {
                case 0:
                    strcat(encoder_read_str, " OFF");
                    encoder_read_str_len = 24;
                    break;
                case 1:
                    strcat(encoder_read_str, " ON");
                    encoder_read_str_len = 23;
                    break;
            }
            for(i = encoder_read_str_len; i != 0; i--)
                {packet_data_param[5+start_byte + encoder_read_str_len - i] = encoder_read_str[encoder_read_str_len - i];}
            //The following byte indicates the number of menus at the end of the packet to send
            packet_data_param[5+start_byte + encoder_read_str_len] = 2;

            /*-----------------MOTOR READ-----------------*/

			start_byte = start_byte + (uint16_t)(PARAM_BYTE_SLOT) ;
            sprintf(motor_read_str, "%u - Read Motor:", first_imu_parameter+N_IMU_Connected+3);
            packet_data_param[2+start_byte] = TYPE_FLAG;
            packet_data_param[3+start_byte] = 1;
            packet_data_param[4+start_byte] = c_mem.read_motor;
            switch(c_mem.read_motor) {
                case 0:
                    strcat(motor_read_str, " OFF");
                    motor_read_str_len = 21;
                    break;
                case 1:
                    strcat(motor_read_str, " ON");
                    motor_read_str_len = 20;
                    break;
            }
            for(i = motor_read_str_len; i != 0; i--)
                {packet_data_param[5+start_byte + motor_read_str_len - i] = motor_read_str[motor_read_str_len - i];}
            //The following byte indicates the number of menus at the end of the packet to send
            packet_data_param[5+start_byte + motor_read_str_len] = 2;

            /*-----------------EXPANSION PORT READ-----------------*/

			start_byte = start_byte + (uint16_t)(PARAM_BYTE_SLOT) ;
            sprintf(exp_port_read_str, "%u - Read Expansion port:", first_imu_parameter+N_IMU_Connected+4);
            packet_data_param[2+start_byte] = TYPE_FLAG;
            packet_data_param[3+start_byte] = 1;
            packet_data_param[4+start_byte] = c_mem.read_exp_port;
            switch(c_mem.read_exp_port) {
                case 0:
                    strcat(exp_port_read_str, " None");
                    exp_port_read_str_len = 31;
                    break;
                case 1:
                    strcat(exp_port_read_str, " SD/RTC board");
                    exp_port_read_str_len = 39;
                    break;
                case 2:
					strcat(exp_port_read_str, " WiFi board");
					exp_port_read_str_len = 37;
					break;
                case 3:
					strcat(exp_port_read_str, " Other");
					exp_port_read_str_len = 32;
					break;
            }
            for(i = exp_port_read_str_len; i != 0; i--)
                {packet_data_param[5+start_byte + exp_port_read_str_len - i] = exp_port_read_str[exp_port_read_str_len - i];}
            //The following byte indicates the number of menus at the end of the packet to send
            packet_data_param[5+start_byte + exp_port_read_str_len] = 3;

            /*------------PARAMETERS MENU-----------*/
            start_byte = start_byte + PARAM_BYTE_SLOT;
            for(i = spi_delay_menu_len; i!= 0; i--)
                packet_data_param[(uint16_t)(2 + start_byte) + spi_delay_menu_len - i] = spi_delay_menu[spi_delay_menu_len - i];

            start_byte = start_byte + PARAM_MENU_SLOT;
			for(i = on_off_menu_len; i!= 0; i--)
				packet_data_param[(uint16_t)(2 + start_byte) + on_off_menu_len - i] = on_off_menu[on_off_menu_len - i];

			start_byte = start_byte + PARAM_MENU_SLOT;
			for(i = exp_port_menu_len; i!= 0; i--)
				packet_data_param[(uint16_t)(2 + start_byte) + exp_port_menu_len - i] = exp_port_menu[exp_port_menu_len - i];

            packet_data_param[packet_length - 1] = LCRChecksum(packet_data_param,packet_length - 1); // [GS]				
			commWrite(packet_data_param, packet_length);

        break;

        //=========================================================     other_params
        default: 

            if (index < first_imu_parameter-1)
                break;
            
            if (index >= first_imu_parameter+N_IMU_Connected) {
            	uint8_t aux = index - (first_imu_parameter+N_IMU_Connected);
            	switch(aux) {
					case 0:
						g_mem.SPI_read_delay = g_rx.buffer[3];  //SPI read delay - uint8
						break;
					case 1:
						g_mem.read_imu = g_rx.buffer[3];  //IMU read- uint8
						break;
					case 2:
						g_mem.read_encoders = g_rx.buffer[3];  //Encoders read - uint8
						break;
					case 3:
						g_mem.read_motor = g_rx.buffer[3];  //Motor read - uint8
						break;
					case 4:
						g_mem.read_exp_port = g_rx.buffer[3];  //Expansion port read- uint8
						break;
            	}
                break;
            }
            
            if (index == first_imu_parameter-1) {
                g_mem.id = g_rx.buffer[3];          //ID - uint8
			} else {
                //Set Imu table (index > = first_imu_parameter)
                g_mem.IMU_conf[IMU_connected[index-first_imu_parameter]][0] = g_rx.buffer[3];
                g_mem.IMU_conf[IMU_connected[index-first_imu_parameter]][1] = g_rx.buffer[4];
                g_mem.IMU_conf[IMU_connected[index-first_imu_parameter]][2] = g_rx.buffer[5];
                g_mem.IMU_conf[IMU_connected[index-first_imu_parameter]][3] = g_rx.buffer[6];
                g_mem.IMU_conf[IMU_connected[index-first_imu_parameter]][4] = g_rx.buffer[7];
                
                // Recompute IMU packets dimension
                imus_data_size = 1; //header    
                for (i = 0; i < N_IMU_Connected; i++)    {
                    single_imu_size[IMU_connected[i]] = 1 + 6*g_mem.IMU_conf[IMU_connected[i]][0] + 6*g_mem.IMU_conf[IMU_connected[i]][1] + 6*g_mem.IMU_conf[IMU_connected[i]][2] + 8*g_mem.IMU_conf[IMU_connected[i]][3] + 2*g_mem.IMU_conf[IMU_connected[i]][4]+ 1;
                    imus_data_size = imus_data_size + single_imu_size[IMU_connected[i]];
                }
                imus_data_size = imus_data_size + 1;    //checksum
            }
        break;
    }
}
